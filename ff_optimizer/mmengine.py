try:
    pass
except:
    pass
import os
from random import randint
from shutil import copyfile, rmtree
from pathlib import Path

import GPUtil

from . import utils


class MMEngine:
    def __init__(self, inp):
        self.inp = inp
        # Account for being in basedir/sampledir/x_cycle_x/
        if inp.conformers is None:
            self.coordPath = inp.dynamicsdir.absolute() / inp.coors
        else:
            self.coordPath = inp.dynamicsdir.absolute() / inp.conformers
        self.startIndex, self.endIndex, self.splitIndex = self.getIndices()
        self.symbols = None

    def checkForTCFormatting(self):
        with open(self.coordPath, "r") as f:
            try:
                natoms = int(f.readline())
                if "xyz file generated by terachem" in f.readline():
                    terachemFormat = True
                else:
                    terachemFormat = False
                    print(
                        f"Warning: coordinates file {self.coordPath} does not have TeraChem formatted comment lines"
                    )
                    print("Assuming coordinates are sequential and 0-indexed")
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.coordPath} is not correctly formatted"
                )
        return terachemFormat

    def readTCFormat(self):
        start = self.inp.start
        end = self.inp.end
        split = self.inp.split
        coordIndex = []
        splitIndex = None
        with open(self.coordPath, "r") as f:
            try:
                for line in f.readlines():
                    if "frame" in line:
                        coordIndex.append(int(line.split()[2]))
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.inp.coords} is not correctly formatted"
                )
        nframes = len(coordIndex)
        startIndex = 0
        if start != None:
            while coordIndex[startIndex] < start and startIndex < nframes - 1:
                startIndex += 1
        endIndex = len(coordIndex) - 1
        if end != None:
            while coordIndex[endIndex] > end and endIndex > 0:
                endIndex -= 1
        splitIndex = 0
        if split != None:
            while coordIndex[splitIndex] < split and splitIndex < nframes - 1:
                splitIndex += 1
        return startIndex, endIndex, splitIndex

    def countFrames(self):
        with open(self.coordPath, "r") as f:
            try:
                natoms = int(f.readline())
                lines = list(f.readlines())
                nlines = len(lines)
                for line in lines[::-1]:
                    if len(line.split()) == 0:
                        nlines -= 1
                    else:
                        break
                nframes = int(nlines / (natoms + 2))
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.inp.coords} is not correctly formatted"
                )
        return nframes

    # 0-indexed
    # TODO: figure out what to do with this awful function
    # It really shouldn't be my responsibility to untangle an awful coors.xyz file
    def getIndices(self):
        start = self.inp.start
        end = self.inp.end
        split = self.inp.split
        terachemFormat = self.checkForTCFormatting()
        nframes = self.countFrames()
        if terachemFormat:
            start, end, split = self.readTCFormat()
        if end is not None:
            if end > nframes - 1:
                end = nframes - 1
        else:
            end = nframes - 1
        if split is not None:
            if split > nframes - 1:
                raise ValueError("There must be frames after split")
        else:
            split = 0
        if start is not None:
            if start > nframes - 1:
                raise ValueError("There must be frames after start")
        else:
            start = 0
        return start, end, split

    def getFrames(self, samplePath="."):
        frames = []
        if self.splitIndex == 0:
            for i in range((self.inp.nvalids + 1) * self.inp.conformersperset):
                frames.append(randint(self.startIndex, self.endIndex))
        else:
            for i in range(self.inp.conformersperset):
                frames.append(randint(self.startIndex, self.splitIndex - 1))
            for i in range(self.inp.nvalids * self.inp.conformersperset):
                frames.append(randint(self.splitIndex, self.endIndex))
        return frames

    # 0-indexed
    def getFrame(self, index, dest):
        frame = []
        with open(self.coordPath, "r") as f:
            natoms = int(f.readline())
            lines = f.readlines()
            for i in range(len(lines)):
                if int(i / (natoms + 2)) == index and (i + 1) % (natoms + 2) > 1:
                    frame.append(lines[i].split()[1:])
                elif int((i + 1) / (natoms + 2)) > index:
                    break
        if len(frame) != natoms:
            raise RuntimeError("Error finding frame in coordinates XYZ file")
        utils.writeRst(frame, natoms, dest)

    def writeMMFinished(self, f=Path("./")):
        with open(f / "MMFinished.txt", "w") as f:
            f.write("MM sampling finished\n")
            f.write("Remove this file\n")
            f.write("If you want to force a recalculation of the MM sampling")

    def getFolders(self):
        folders = [Path("train")]
        for i in range(1, self.inp.nvalids + 1):
            folders.append(Path(f"valid_{i}"))
        return folders

    def getMMSamples(self):
        self.prmtop = self.setup()
        allFrames = self.getFrames()
        folders = self.getFolders()
        for i, f in enumerate(folders):
            # skip restarted folders
            if self.inp.restart and f.is_dir():
                continue
            f.mkdir(exist_ok=True)
            frames = allFrames[i * self.inp.conformersperset : (i + 1) * self.inp.conformersperset]
            for frame in frames:
                self.getFrame(frame, f / f"{frame}.rst7")
            os.chdir(f)
            if i < self.inp.conformersperset:
                mdin = self.inp.trainmdin
            else:
                mdin = self.inp.validmdin
            self.sample(frames, mdin)
            self.writeMMFinished()
            os.chdir("..")


    # This is the function that has to be implemented for every MMEngine
    def sample(self, frames, mdin):
        pass

    # This is hard-coded to use Amber
    def setup(self):
        os.system(f"tleap -f setup.leap > leap.out")
        prmtop = None
        for f in os.listdir():
            if f.endswith(".prmtop"):
                prmtop = f
        if prmtop == None:
            raise RuntimeError(
                f"Tleap failed to create a new .prmtop file, check {os.path.join(os.getcwd(),'leap.out')} for more information"
            )
        if self.symbols is None:
            self.symbols = utils.getSymbolsFromPrmtop(prmtop)
        return prmtop

    # This function is currently hard-coded to use .nc trajectory files
    def restart(self):
        self.prmtop = self.setup()
        for f in self.getFolders():
            # getMMSamples will take care of any folders that haven't been created yet
            if not f.is_dir():
                continue
            # Skip finished jobs
            if (f / "MMFinished.txt").is_file():
                continue
            # get conformer names
            conformers = []
            for g in os.listdir(f):
                if g.endswith("rst7") and "heat" not in g and "_" not in g:
                    conformers.append(g)
            if len(conformers) < self.inp.conformersperset:
                rmtree(f)
                continue
            redoFrames = []
            # record which initial conditions haven't had MD run yet
            for conformer in conformers:
                name = conformer.split(".")[0]
                if not (f / f"{name}.nc").is_file():
                    redoFrames.append(int(name))
            # if some ICs haven't done MD yet, run it (with the right input file)
            print(len(redoFrames))
            if len(redoFrames) > 0:
                if f.name.startswith("train"):
                    mdin = self.inp.trainmdin
                else:
                    mdin = self.inp.validmdin
                os.chdir(f)
                self.sample(redoFrames, mdin)
                os.chdir("..")
            else:
                print("writing mmfinished")
                self.writeMMFinished(f)

        self.getMMSamples()


# class AmberEngine(MMEngine):
#    def __init__(self, options):
#        super().__init__(options)
#        inputs = sander.gas_input()
#        sander.setup(prmtop, options["coordinates"], None, inputs)


class ExternalAmberEngine(MMEngine):
    def __init__(self, inp):
        self.inp = inp
        self.heatCounter = inp.heatCounter
        self.checkForGPUs()
        super().__init__(inp)

    def checkForGPUs(self):
        try:
            deviceIDs = GPUtil.getAvailable(maxLoad=0.1)
            if len(deviceIDs) > 0:
                print("Nvidia GPUs detected; defaulting to pmemd.cuda")
                self.amberExe = "pmemd.cuda"
                os.environ["CUDA_VISIBLE_DEVICES"] = str(deviceIDs[0])
            else:
                print("No Nvidia GPUs available; defaulting to sander")
                self.amberExe = "pmemd"
        except:
            print("No Nvidia GPUs available; defaulting to sander")
            self.amberExe = "pmemd"

    def runSander(self, prmtop, mdin, mdout, mdcrd, mdtraj, restart, mdvels=None):
        if not os.path.isfile(prmtop):
            raise RuntimeError(f"Cannot find prmtop {prmtop} in {os.getcwd()}")
        if not os.path.isfile(mdin):
            raise RuntimeError(f"Cannot find mdin {mdin} in {os.getcwd()}")
        if not os.path.isfile(mdcrd):
            raise RuntimeError(f"Cannot find input crd {mdcrd} in {os.getcwd()}")
        if mdvels is None:
            os.system(
                f"{self.amberExe} -O -p {prmtop} -i {mdin} -o {mdout} -c {mdcrd} -x {mdtraj} -r {restart}"
            )
        else:
            os.system(
                f"{self.amberExe} -O -p {prmtop} -i {mdin} -o {mdout} -c {mdcrd} -x {mdtraj} -r {restart} -v {mdvels}"
            )
        if not os.path.isfile(restart):
            if self.amberExe == "pmemd.cuda":
                print("pmemd.cuda failed; trying MM sampling with pmemd")
                self.amberExe = "pmemd"
                self.runSander(
                    prmtop, mdin, mdout, mdcrd, mdtraj, restart, mdvels=mdvels
                )
            else:
                raise RuntimeError(
                    f"MM dynamics with input {mdin} failed in {os.getcwd()}"
                )

    def sample(self, frames, mdin):
        numXYZs = 0
        for frame in frames:
            name = str(frame)
            # Right now needs to be copy instead of move for restarting
            copyfile(f"{name}.rst7", f"{name}_heat0.rst7")
            for j in range(1, self.heatCounter + 1):
                self.runSander(
                    os.path.join("..", self.prmtop),
                    os.path.join("..", f"heat{str(j)}.in"),
                    f"{name}_heat{str(j)}.out",
                    f"{name}_heat{str(j-1)}.rst7",
                    f"{name}_heat{str(j)}.nc",
                    f"{name}_heat{str(j)}.rst7",
                )
            self.runSander(
                os.path.join("..", self.prmtop),
                os.path.join("..", mdin),
                f"{name}_.out",
                f"{name}_heat{str(self.heatCounter)}.rst7",
                f"{name}.nc",
                f"{name}_md.rst7",
                mdvels=f"{name}_vel.nc",
            )
            numXYZs += utils.convertNCtoXYZs(f"{name}.nc", self.symbols, numXYZs)


class ExternalOpenMMEngine(MMEngine):
    def __init__(self, options):
        super().__init__(options)

    # The OpenMM python file must satisfy the following conditions:
    # 1. It accepts as arguments (in order) the .prmtop and .rst7 files
    # 2. It performs all necessary equilibrations internally
    # 3. It produces a {name}.nc file containing the sampled geometries
    def sample(self, frames, mdin):
        numXYZs = 0
        for frame in frames:
            name = str(frame)
            os.system(
                f"python {os.path.join('..',mdin)} {self.prmtop} {name}.rst7 > {name}.out"
            )
            numXYZs += utils.convertNCtoXYZs(f"{name}.nc", self.symbols, numXYZs)
