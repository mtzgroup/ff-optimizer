import os
import subprocess
from pathlib import Path
from random import randint
from shutil import copyfile

import GPUtil

from . import utils


class MMEngine:
    def __init__(self, inp: 'Input'):
        """
        Initialize the MMEngine.

        Args:
            inp (Input): Input object containing configuration parameters.
        """
        self.inp = inp
        # Account for being in basedir/sampledir/x_cycle_x/
        if inp.conformers is None:
            self.coordPath = inp.dynamicsdir.absolute() / inp.coors
        else:
            self.coordPath = inp.dynamicsdir.absolute() / inp.conformers
        self.startIndex, self.endIndex, self.splitIndex = self.getIndices()
        self.symbols = None

    def checkForTCFormatting(self):
        """
        Check if the coordinates file has TeraChem formatting.

        Returns:
            bool: True if the file has TeraChem formatting, False otherwise.

        Raises:
            RuntimeError: If the XYZ coordinates file is not correctly formatted.
        """
        with open(self.coordPath, "r") as f:
            try:
                int(f.readline())
                if "xyz file generated by terachem" in f.readline():
                    terachemFormat = True
                else:
                    terachemFormat = False
                    print(
                        f"Warning: coordinates file {self.coordPath} does not have TeraChem formatted comment lines"
                    )
                    print("Assuming coordinates are sequential and 0-indexed")
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.coordPath} is not correctly formatted"
                )
        return terachemFormat

    def readTCFormat(self):
        """
        Read TeraChem formatted coordinates file.

        Returns:
            tuple: A tuple containing startIndex, endIndex, and splitIndex.

        Raises:
            RuntimeError: If the XYZ coordinates file is not correctly formatted.
        """
        start = self.inp.start
        end = self.inp.end
        split = self.inp.split
        coordIndex = []
        splitIndex = None
        with open(self.coordPath, "r") as f:
            try:
                for line in f.readlines():
                    if "frame" in line:
                        coordIndex.append(int(line.split()[2]))
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.inp.coords} is not correctly formatted"
                )
        nframes = len(coordIndex)
        startIndex = 0
        if start != None:
            while coordIndex[startIndex] < start and startIndex < nframes - 1:
                startIndex += 1
        endIndex = len(coordIndex) - 1
        if end != None:
            while coordIndex[endIndex] > end and endIndex > 0:
                endIndex -= 1
        splitIndex = 0
        if split != None:
            while coordIndex[splitIndex] < split and splitIndex < nframes - 1:
                splitIndex += 1
        return startIndex, endIndex, splitIndex

    def countFrames(self):
        """
        Count the number of frames in the coordinates file.

        Returns:
            int: The number of frames in the coordinates file.

        Raises:
            RuntimeError: If the XYZ coordinates file is not correctly formatted.
        """
        with open(self.coordPath, "r") as f:
            try:
                natoms = int(f.readline())
                lines = list(f.readlines())
                nlines = len(lines) + 1  # for the f.readline() call
                for line in lines[::-1]:
                    if len(line.split()) == 0:
                        nlines -= 1
                    else:
                        break
                nframes = int(nlines / (natoms + 2))
            except:
                raise RuntimeError(
                    f"XYZ coordinates file {self.inp.coords} is not correctly formatted"
                )
        return nframes

    def getIndices(self):
        """
        Get the start, end, and split indices for the coordinates.

        Returns:
            tuple: A tuple containing startIndex, endIndex, and splitIndex.

        Raises:
            ValueError: If the provided indices are invalid.
        """
        start = self.inp.start
        end = self.inp.end
        split = self.inp.split
        nframes = self.countFrames()
        if end is not None:
            if end > nframes - 1:
                end = nframes - 1
            if end < 0:
                end = 0
        else:
            end = nframes - 1
        if split is not None:
            if split > nframes - 1:
                raise ValueError("There must be frames after split")
            if split < 0:
                split = 0
        else:
            split = 0
        if start is not None:
            if start > nframes - 1:
                raise ValueError("There must be frames after start")
            if start < 0:
                start = 0
        else:
            start = 0
        return start, end, split

    def getFrames(self, samplePath: Path = Path(".")):
        """
        Get random frames for sampling.

        Args:
            samplePath (Path): Path to the sample directory.

        Returns:
            list: List of randomly selected frame indices.
        """
        frames = []
        if self.splitIndex == 0:
            for i in range((self.inp.nvalids + 1) * self.inp.conformersperset):
                frames.append(randint(self.startIndex, self.endIndex))
        else:
            for i in range(self.inp.conformersperset):
                frames.append(randint(self.startIndex, self.splitIndex - 1))
            for i in range(self.inp.nvalids * self.inp.conformersperset):
                frames.append(randint(self.splitIndex, self.endIndex))
        return frames

    def getFrame(self, index: int, dest: Path):
        """
        Extract a specific frame from the coordinates file.

        Args:
            index (int): Index of the frame to extract.
            dest (Path): Destination path to write the extracted frame.

        Raises:
            RuntimeError: If there's an error finding the frame in the coordinates file.
        """
        frame = []
        with open(self.coordPath, "r") as f:
            natoms = int(f.readline())
            lines = f.readlines()
            for i in range(len(lines)):
                if int(i / (natoms + 2)) == index and (i + 1) % (natoms + 2) > 1:
                    frame.append(lines[i].split()[1:])
                elif int((i + 1) / (natoms + 2)) > index:
                    break
        if len(frame) != natoms:
            raise RuntimeError("Error finding frame in coordinates XYZ file")
        utils.writeRst(frame, natoms, dest)

    def writeMMFinished(self, f: Path = Path(".")):
        """
        Write a file indicating that MM sampling is finished.

        Args:
            f (Path): Path to write the file.
        """
        with open(f / "MMFinished.txt", "w") as f:
            f.write("MM sampling finished\n")
            f.write("Remove this file\n")
            f.write("If you want to force a recalculation of the MM sampling")

    def getFolders(self):
        """
        Get a list of folder names for training and validation.

        Returns:
            list: List of folder names.
        """
        folders = [Path("train")]
        for i in range(1, self.inp.nvalids + 1):
            folders.append(Path(f"valid_{i}"))
        return folders

    def getMMSamples(self):
        """
        Perform MM sampling.

        This method sets up the sampling process, generates frames,
        and runs the sampling for each folder.
        """
        self.prmtop = self.setup()
        allFrames = self.getFrames()
        folders = self.getFolders()
        for i, f in enumerate(folders):
            # skip restarted folders
            if self.inp.restart and f.is_dir():
                continue
            f.mkdir(exist_ok=True)
            frames = allFrames[
                i * self.inp.conformersperset : (i + 1) * self.inp.conformersperset
            ]
            for frame in frames:
                self.getFrame(frame, f / f"{frame}.rst7")
            os.chdir(f)
            if i < self.inp.conformersperset:
                mdin = self.inp.trainmdin
            else:
                mdin = self.inp.validmdin
            self.sample(frames, mdin)
            self.writeMMFinished()
            os.chdir("..")

    def sample(self, frames, mdin):
        """
        Perform sampling. This method should be implemented by subclasses.

        Args:
            frames (list): List of frame indices to sample.
            mdin (str): Input file for the sampling process.
        """
        pass

    def setup(self):
        """
        Set up the MM engine.

        Returns:
            str: Name of the parameter topology file.

        Raises:
            RuntimeError: If tleap fails to create a new .prmtop file.
        """
        os.system(f"tleap -f setup.leap > leap.out")
        prmtop = None
        for f in os.listdir():
            if f.endswith(".prmtop"):
                prmtop = f
        if prmtop == None:
            raise RuntimeError(
                f"Tleap failed to create a new .prmtop file, check {Path.cwd()/'leap.out'} for more information"
            )
        if self.symbols is None:
            self.symbols = utils.getSymbolsFromPrmtop(prmtop)
        return prmtop

    def getConformerNames(self, f: Path):
        """
        Get the names of conformer files in a directory.

        Args:
            f (Path): Path to the directory.

        Returns:
            list: List of conformer file names.
        """
        conformers = []
        for g in os.listdir(f):
            if g.endswith("rst7") and "heat" not in g and "_" not in g:
                conformers.append(g)
        return conformers

    def getRedoFrames(self, f: Path, conformers: list):
        """
        Get frames that need to be redone.

        Args:
            f (Path): Path to the directory.
            conformers (list): List of conformer file names.

        Returns:
            list: List of frame indices that need to be redone.
        """
        redoFrames = []
        for conformer in conformers:
            name = conformer.split(".")[0]
            if not (f / f"{name}.nc").is_file():
                redoFrames.append(int(name))
        return redoFrames

    def restart(self):
        """
        Restart the MM sampling process.

        This method checks for existing folders and conformers,
        and restarts the sampling process where needed.
        """
        self.prmtop = self.setup()
        for f in self.getFolders():
            # getMMSamples will take care of any folders that haven't been created yet
            if not f.is_dir():
                continue
            # Skip finished jobs
            if (f / "MMFinished.txt").is_file():
                continue
            # get conformer names
            conformers = self.getConformerNames(f)
            if len(conformers) < self.inp.conformersperset:
                utils.rmrf(f)
                continue
            # record which initial conditions haven't had MD run yet
            redoFrames = self.getRedoFrames(f, conformers)
            # if some ICs haven't done MD yet, run it (with the right input file)
            if len(redoFrames) > 0:
                if f.name.startswith("train"):
                    mdin = self.inp.trainmdin
                else:
                    mdin = self.inp.validmdin
                os.chdir(f)
                self.sample(redoFrames, mdin)
                os.chdir("..")
            else:
                self.writeMMFinished(f)
        self.getMMSamples()


class ExternalAmberEngine(MMEngine):
    def __init__(self, inp):
        """
        Initialize the ExternalAmberEngine.

        Args:
            inp (Input): Input object containing configuration parameters.
        """
        self.inp = inp
        self.heatCounter = inp.heatCounter
        self.checkForGPUs()
        super().__init__(inp)

    def checkForGPUs(self):
        """
        Check for available GPUs and set the appropriate Amber executable.
        """
        try:
            deviceIDs = GPUtil.getAvailable(maxLoad=0.1)
            if len(deviceIDs) > 0:
                print("Nvidia GPUs detected; defaulting to pmemd.cuda")
                self.amberExe = "pmemd.cuda"
                os.environ["CUDA_VISIBLE_DEVICES"] = str(deviceIDs[0])
            else:
                print("No Nvidia GPUs available; defaulting to sander")
                self.amberExe = "pmemd"
        except:
            print("No Nvidia GPUs available; defaulting to sander")
            self.amberExe = "pmemd"

    def runSander(self, prmtop: Path, mdin: Path, mdout: Path, mdcrd: Path, mdtraj: Path, restart: Path, mdvels: Path = None):
        """
        Run Amber's sander or pmemd.

        Args:
            prmtop (Path): Path to the parameter topology file.
            mdin (Path): Path to the input file.
            mdout (Path): Path to the output file.
            mdcrd (Path): Path to the input coordinates file.
            mdtraj (Path): Path to the trajectory output file.
            restart (Path): Path to the restart file.
            mdvels (Path, optional): Path to the velocities file.

        Raises:
            RuntimeError: If the Amber simulation fails.
        """
        if not prmtop.is_file():
            raise RuntimeError(f"Cannot find prmtop {prmtop} in {os.getcwd()}")
        if not mdin.is_file():
            raise RuntimeError(f"Cannot find mdin {mdin} in {os.getcwd()}")
        if not mdcrd.is_file():
            raise RuntimeError(f"Cannot find input crd {mdcrd} in {os.getcwd()}")
        command = [
            self.amberExe,
            "-O",
            "-p",
            str(prmtop),
            "-i",
            str(mdin),
            "-o",
            str(mdout),
            "-c",
            str(mdcrd),
            "-x",
            str(mdtraj),
            "-r",
            str(restart),
        ]
        if mdvels is not None:
            command += ["-v", str(mdvels)]
        result = subprocess.run(
            command, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        with open("md.out", "a") as f:
            f.write(result.stdout)
        with open("md.err", "a") as f:
            f.write(result.stderr)

        if not restart.is_file():
            if self.amberExe == "pmemd.cuda":
                print("pmemd.cuda failed; trying MM sampling with pmemd")
                self.amberExe = "pmemd"
                self.runSander(
                    prmtop, mdin, mdout, mdcrd, mdtraj, restart, mdvels=mdvels
                )
            else:
                raise RuntimeError(
                    f"MM dynamics with input {mdin} failed in {os.getcwd()}"
                )

    def sample(self, frames, mdin):
        """
        Perform sampling using Amber.

        Args:
            frames (list): List of frame indices to sample.
            mdin (Path): Path to the input file for the sampling process.
        """
        numXYZs = 0
        for frame in frames:
            name = str(frame)
            # Right now needs to be copy instead of move for restarting
            copyfile(f"{name}.rst7", f"{name}_heat0.rst7")
            for j in range(1, self.heatCounter + 1):
                self.runSander(
                    Path("..") / self.prmtop,
                    Path("..") / f"heat{str(j)}.in",
                    Path(f"{name}_heat{str(j)}.out"),
                    Path(f"{name}_heat{str(j-1)}.rst7"),
                    Path(f"{name}_heat{str(j)}.nc"),
                    Path(f"{name}_heat{str(j)}.rst7"),
                )
            self.runSander(
                Path("..") / self.prmtop,
                Path("..") / mdin,
                Path(f"{name}_.out"),
                Path(f"{name}_heat{str(self.heatCounter)}.rst7"),
                Path(f"{name}.nc"),
                Path(f"{name}_md.rst7"),
                mdvels=Path(f"{name}_vel.nc"),
            )
            numXYZs += utils.convertNCtoXYZs(f"{name}.nc", self.symbols, numXYZs)


class ExternalOpenMMEngine(MMEngine):
    def __init__(self, options):
        """
        Initialize the ExternalOpenMMEngine.

        Args:
            options (Input): Input object containing configuration parameters.
        """
        super().__init__(options)

    # The OpenMM python file must satisfy the following conditions:
    # 1. It accepts as arguments (in order) the .prmtop and .rst7 files
    # 2. It performs all necessary equilibrations internally
    # 3. It produces a {name}.nc file containing the sampled geometries
    def sample(self, frames, mdin):
        """
        Perform sampling using OpenMM.

        Args:
            frames (list): List of frame indices to sample.
            mdin (Path): Path to the Python script for the OpenMM MD run.
        """
        numXYZs = 0
        for frame in frames:
            name = str(frame)
            os.system(
                f"python {Path('..') / mdin} {self.prmtop} {name}.rst7 > {name}.out"
            )
            numXYZs += utils.convertNCtoXYZs(f"{name}.nc", self.symbols, numXYZs)